// import React, { useState, useRef, useEffect } from 'react'

// const PodcastMode = ({ analysis, outline }) => {
//   const [isPlaying, setIsPlaying] = useState(false)
//   const [currentSection, setCurrentSection] = useState(0)
//   const [podcastScript, setPodcastScript] = useState([])
//   const [playbackSpeed, setPlaybackSpeed] = useState(1.0)
//   const [currentTime, setCurrentTime] = useState(0)
//   const [duration, setDuration] = useState(0)
//   const speechSynthesis = useRef(window.speechSynthesis)
//   const currentUtterance = useRef(null)

//   useEffect(() => {
//     if (analysis && outline) {
//       generateGeminiPodcastScript()
//     }
//   }, [analysis, outline])

//   const generateGeminiPodcastScript = () => {
//     const script = [
//       {
//         title: "Gemini AI Introduction",
//         content: `Welcome to your AI-powered document analysis, enhanced by Google's Gemini AI. Today we're analyzing: ${outline?.title || 'your document'}. This document has ${outline?.outline?.length || 0} main sections across ${analysis?.document_info?.page_count || 0} pages. Our analysis is powered by ${analysis?.metadata?.ai_model || 'Gemini 2.5 Flash'}.`,
//         duration: 20
//       },
//       {
//         title: "Document Overview",
//         content: `Let me give you a comprehensive summary generated by Gemini AI: ${analysis?.summary || 'This document contains important information relevant to your selected persona.'}`,
//         duration: 25
//       }
//     ]

//     // Add persona-specific analysis
//     if (analysis?.metadata?.persona) {
//       script.push({
//         title: `${analysis.metadata.persona} Perspective`,
//         content: `From a ${analysis.metadata.persona} perspective, this document has a relevance score of ${analysis?.metadata?.relevance_score ? (analysis.metadata.relevance_score * 100).toFixed(0) + '%' : 'high relevance'}. Gemini AI has tailored this analysis specifically for your professional role.`,
//         duration: 15
//       })
//     }

//     // Add section-by-section breakdown
//     if (outline?.outline) {
//       outline.outline.forEach((section, index) => {
//         script.push({
//           title: `Section ${index + 1}: ${section.text}`,
//           content: `Moving to ${section.text} on page ${section.page}. This is a ${section.level} heading, indicating its importance in the document structure. Gemini AI has identified this as a key organizational element.`,
//           duration: 12
//         })
//       })
//     }

//     // Add Gemini-generated insights
//     if (analysis?.insights?.insights) {
//       script.push({
//         title: "Gemini AI Key Insights",
//         content: `Here are the key insights discovered by Gemini AI: ${analysis.insights.insights.join('. ')}`,
//         duration: 30
//       })
//     }

//     // Add interesting fact
//     if (analysis?.insights?.fact) {
//       script.push({
//         title: "Gemini Discovery",
//         content: `Here's an interesting discovery from Gemini AI: ${analysis.insights.fact}`,
//         duration: 12
//       })
//     }

//     // Add contradictions if found
//     if (analysis?.insights?.contradiction && analysis.insights.contradiction !== "No contradictions found") {
//       script.push({
//         title: "Critical Analysis",
//         content: `Gemini AI has identified an important consideration: ${analysis.insights.contradiction}`,
//         duration: 15
//       })
//     }

//     // Add inspiration/connections
//     if (analysis?.insights?.inspiration) {
//       script.push({
//         title: "Professional Insights",
//         content: `Gemini AI suggests: ${analysis.insights.inspiration}`,
//         duration: 12
//       })
//     }

//     // Add conclusion
//     script.push({
//       title: "Gemini AI Conclusion",
//       content: `That concludes your document analysis powered by Google's Gemini AI. The key themes identified were: ${analysis?.document_info?.keywords?.slice(0, 3).join(', ') || 'comprehensive analysis and insights'}. Thank you for using our Gemini-powered PDF AI Assistant.`,
//       duration: 18
//     })

//     setPodcastScript(script)
//     setDuration(script.reduce((total, section) => total + section.duration, 0))
//   }

//   const playPodcast = () => {
//     if (podcastScript.length === 0) return

//     setIsPlaying(true)
//     speakSection(currentSection)
//   }

//   const speakSection = (sectionIndex) => {
//     if (sectionIndex >= podcastScript.length) {
//       setIsPlaying(false)
//       setCurrentSection(0)
//       setCurrentTime(0)
//       return
//     }

//     const section = podcastScript[sectionIndex]
//     const utterance = new SpeechSynthesisUtterance(section.content)
    
//     utterance.rate = playbackSpeed
//     utterance.pitch = 1.0
//     utterance.volume = 1.0

//     utterance.onend = () => {
//       if (isPlaying) {
//         const nextSection = sectionIndex + 1
//         setCurrentSection(nextSection)
//         setCurrentTime(currentTime + section.duration)
        
//         setTimeout(() => {
//           if (isPlaying) speakSection(nextSection)
//         }, 500)
//       }
//     }

//     currentUtterance.current = utterance
//     speechSynthesis.current.speak(utterance)
//   }

//   const pausePodcast = () => {
//     setIsPlaying(false)
//     speechSynthesis.current.cancel()
//   }

//   const restartPodcast = () => {
//     speechSynthesis.current.cancel()
//     setCurrentSection(0)
//     setCurrentTime(0)
//     setIsPlaying(false)
//   }

//   const formatTime = (seconds) => {
//     const mins = Math.floor(seconds / 60)
//     const secs = Math.floor(seconds % 60)
//     return `${mins}:${secs.toString().padStart(2, '0')}`
//   }

//   return (
//     <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
//       <h3 className="text-xl font-semibold text-white mb-6 flex items-center">
//         <span className="text-2xl mr-3">🎧</span>
//         Gemini AI Podcast Mode
//         <span className="ml-auto text-sm text-red-400">Powered by Gemini</span>
//       </h3>

//       {/* Podcast Player */}
//       <div className="bg-gray-900 rounded-lg p-4 mb-6">
//         <div className="flex items-center justify-between mb-4">
//           <div>
//             <h4 className="text-white font-medium">Gemini AI Document Analysis</h4>
//             <p className="text-gray-400 text-sm">
//               {podcastScript[currentSection]?.title || 'Ready to start'}
//             </p>
//           </div>
//           <div className="text-right">
//             <div className="text-white text-sm">{formatTime(currentTime)} / {formatTime(duration)}</div>
//             <div className="text-gray-400 text-xs">
//               Section {currentSection + 1} of {podcastScript.length}
//             </div>
//           </div>
//         </div>

//         {/* Progress Bar */}
//         <div className="w-full bg-gray-700 rounded-full h-2 mb-4">
//           <div 
//             className="bg-red-600 h-2 rounded-full transition-all duration-500"
//             style={{ width: `${duration > 0 ? (currentTime / duration) * 100 : 0}%` }}
//           ></div>
//         </div>

//         {/* Controls */}
//         <div className="flex items-center justify-center space-x-4">
//           <button
//             onClick={restartPodcast}
//             className="p-2 rounded-full bg-gray-700 text-white hover:bg-gray-600"
//           >
//             <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
//               <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
//             </svg>
//           </button>

//           <button
//             onClick={isPlaying ? pausePodcast : playPodcast}
//             disabled={podcastScript.length === 0}
//             className="p-3 rounded-full bg-red-600 text-white hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
//           >
//             {isPlaying ? (
//               <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
//                 <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
//               </svg>
//             ) : (
//               <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
//                 <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h8m2 4H7a2 2 0 01-2-2V8a2 2 0 012-2h10a2 2 0 012 2v8a2 2 0 01-2 2z" />
//               </svg>
//             )}
//           </button>

//           <select
//             value={playbackSpeed}
//             onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}
//             className="p-2 rounded bg-gray-700 text-white text-sm border border-gray-600"
//           >
//             <option value={0.5}>0.5x</option>
//             <option value={0.75}>0.75x</option>
//             <option value={1.0}>1x</option>
//             <option value={1.25}>1.25x</option>
//             <option value={1.5}>1.5x</option>
//             <option value={2.0}>2x</option>
//           </select>
//         </div>
//       </div>

//       {/* Gemini-Enhanced Transcript */}
//       <div className="space-y-3 max-h-64 overflow-y-auto">
//         <h4 className="text-white font-medium border-b border-gray-600 pb-2 flex items-center">
//           <span className="mr-2">📜</span>
//           Gemini AI Transcript
//         </h4>
//         {podcastScript.map((section, index) => (
//           <div 
//             key={index} 
//             className={`p-3 rounded border ${
//               index === currentSection && isPlaying
//                 ? 'bg-red-600/10 border-red-600/30 text-white'
//                 : 'bg-gray-900 border-gray-700 text-gray-300'
//             }`}
//           >
//             <div className="font-medium text-sm mb-1 flex items-center">
//               {section.title}
//               {section.title.includes('Gemini') && (
//                 <span className="ml-2 text-xs bg-red-600/20 text-red-400 px-2 py-1 rounded">AI</span>
//               )}
//             </div>
//             <div className="text-xs">{section.content}</div>
//           </div>
//         ))}
//       </div>
//     </div>
//   )
// }

// export default PodcastMode
import React, { useState, useRef, useEffect, useCallback } from 'react'
import { Play, Pause, RotateCcw, Volume2, Clock, SkipForward } from 'lucide-react'

const PodcastMode = ({ analysis, outline, isMultipleFiles, comparison }) => {
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [totalDuration, setTotalDuration] = useState(0)
  const [podcastScript, setPodcastScript] = useState([])
  const [currentSection, setCurrentSection] = useState(0)
  const speechSynthesis = useRef(window.speechSynthesis)
  const utteranceRef = useRef(null)
  const progressInterval = useRef(null)
  const sectionTimeoutRef = useRef(null)
  const isPlayingRef = useRef(false) // ✅ Ref to track playing state reliably

  const generateSectionDescription = (sectionText, persona) => {
    const descriptions = {
      'student': 'important learning content that builds foundational knowledge',
      'business_analyst': 'critical business information for strategic analysis',  
      'researcher': 'valuable research data that supports empirical findings',
      'project_manager': 'essential project information for planning and execution',
      'legal_professional': 'relevant legal information for case preparation',
      'financial_analyst': 'financial data important for quantitative analysis'
    }
    return descriptions[persona] || 'significant information relevant to your analysis'
  }

  const generateComprehensivePodcastScript = useCallback(() => {
    const script = []
    
    if (isMultipleFiles && comparison) {
      script.push({
        title: "Introduction",
        content: `Welcome to your comprehensive document analysis. Today we're analyzing ${comparison.total_files || 'multiple'} documents.`,
        duration: 4
      })

      script.push({
        title: "Overview",
        content: `We completed a comparative analysis of your documents, identifying key themes and patterns.`,
        duration: 5
      })

      if (comparison.common_themes && comparison.common_themes.length > 0) {
        script.push({
          title: "Common Themes",
          content: `Key themes identified: ${comparison.common_themes.slice(0, 3).join(', ')}.`,
          duration: 6
        })
      }
    } else {
      script.push({
        title: "Introduction",  
        content: `Welcome to your document analysis. We're exploring ${outline?.title || 'your document'}.`,
        duration: 4
      })

      script.push({
        title: "Document Overview",
        content: `This document contains ${outline?.outline?.length || 0} main sections across ${analysis?.document_info?.page_count || 1} pages.`,
        duration: 4
      })

      // ✅ Add ALL sections from outline
      const sectionsToProcess = outline?.outline || []
      
      if (sectionsToProcess.length > 0) {
        sectionsToProcess.forEach((section, index) => {
          script.push({
            title: `Section ${index + 1}`,
            content: `Section ${index + 1}: ${section.text}. This appears on page ${section.page}.`,
            duration: 5
          })
        })
      }

      if (analysis?.insights?.insights && analysis.insights.insights.length > 0) {
        script.push({
          title: "Key Insights",
          content: `Key insights: ${analysis.insights.insights[0]}.`,
          duration: 6
        })
      }
    }

    script.push({
      title: "Conclusion",
      content: `This concludes your analysis. Thank you for using our service.`,
      duration: 4
    })

    console.log(`🎵 Generated ${script.length} sections:`, script.map(s => s.title))
    setPodcastScript(script)
    setTotalDuration(script.reduce((total, section) => total + section.duration, 0))
  }, [analysis, outline, isMultipleFiles, comparison])

  useEffect(() => {
    if ((analysis && outline) || (isMultipleFiles && comparison)) {
      generateComprehensivePodcastScript()
    }
  }, [generateComprehensivePodcastScript])

  // ✅ COMPLETELY REWRITTEN playSection with bulletproof progression
  const playSection = useCallback((sectionIndex) => {
    console.log(`🎵 STARTING Section ${sectionIndex + 1}/${podcastScript.length}: ${podcastScript[sectionIndex]?.title}`)
    
    // ✅ Clear any existing timeouts
    if (sectionTimeoutRef.current) {
      clearTimeout(sectionTimeoutRef.current)
      sectionTimeoutRef.current = null
    }
    
    // ✅ Check if we've reached the end
    if (sectionIndex >= podcastScript.length) {
      console.log("✅ ALL SECTIONS COMPLETED!")
      setIsPlaying(false)
      isPlayingRef.current = false
      setCurrentSection(0)
      setCurrentTime(0)
      return
    }

    const section = podcastScript[sectionIndex]
    if (!section) {
      console.log("❌ Section not found, stopping")
      setIsPlaying(false)
      isPlayingRef.current = false
      return
    }

    // ✅ Update current section
    setCurrentSection(sectionIndex)
    
    // ✅ Cancel any existing speech
    if (speechSynthesis.current.speaking) {
      speechSynthesis.current.cancel()
    }
    
    // ✅ Small delay to ensure speech synthesis is ready
    setTimeout(() => {
      if (!isPlayingRef.current) {
        console.log("⏹️ Stopped before starting section")
        return
      }

      const utterance = new SpeechSynthesisUtterance(section.content)
      utterance.rate = 1.1
      utterance.pitch = 1.0
      utterance.volume = 1.0
      
      let hasEnded = false
      
      utterance.onstart = () => {
        console.log(`▶️ SPEECH STARTED: ${section.title}`)
        startProgressTracking(section.duration)
      }

      utterance.onend = () => {
        console.log(`⏹️ SPEECH ENDED: ${section.title}`)
        if (hasEnded) return // Prevent double execution
        hasEnded = true
        
        clearInterval(progressInterval.current)
        
        // ✅ Move to next section ONLY if still playing
        if (isPlayingRef.current && sectionIndex + 1 < podcastScript.length) {
          console.log(`🔄 MOVING TO NEXT: Section ${sectionIndex + 2}`)
          // Small delay before next section
          setTimeout(() => {
            if (isPlayingRef.current) {
              playSection(sectionIndex + 1)
            }
          }, 500)
        } else if (sectionIndex + 1 >= podcastScript.length) {
          console.log("🎉 REACHED FINAL SECTION - COMPLETING")
          setIsPlaying(false)
          isPlayingRef.current = false
          setCurrentSection(0)
          setCurrentTime(0)
        }
      }

      utterance.onerror = (event) => {
        console.error(`❌ SPEECH ERROR: ${section.title}`, event)
        if (hasEnded) return
        hasEnded = true
        
        clearInterval(progressInterval.current)
        
        // ✅ Continue to next section even on error
        if (isPlayingRef.current && sectionIndex + 1 < podcastScript.length) {
          setTimeout(() => {
            if (isPlayingRef.current) {
              playSection(sectionIndex + 1)
            }
          }, 1000)
        }
      }

      utteranceRef.current = utterance
      speechSynthesis.current.speak(utterance)
      
      // ✅ ULTIMATE SAFETY NET: Force next section after timeout
      sectionTimeoutRef.current = setTimeout(() => {
        if (!hasEnded && isPlayingRef.current) {
          console.log(`⚠️ TIMEOUT REACHED for ${section.title} - FORCING NEXT`)
          hasEnded = true
          clearInterval(progressInterval.current)
          
          if (speechSynthesis.current.speaking) {
            speechSynthesis.current.cancel()
          }
          
          if (sectionIndex + 1 < podcastScript.length) {
            playSection(sectionIndex + 1)
          } else {
            setIsPlaying(false)
            isPlayingRef.current = false
            setCurrentSection(0)
            setCurrentTime(0)
          }
        }
      }, (section.duration + 1) * 1000) // Section duration + 1 second
      
    }, 300)
    
  }, [podcastScript])

  const startProgressTracking = (duration) => {
    clearInterval(progressInterval.current)
    let elapsed = 0
    progressInterval.current = setInterval(() => {
      elapsed += 0.3
      setCurrentTime(prev => {
        const newTime = prev + 0.3
        return newTime >= totalDuration ? totalDuration : newTime
      })
      
      if (elapsed >= duration) {
        clearInterval(progressInterval.current)
      }
    }, 300)
  }

  const playPodcast = () => {
    if (podcastScript.length === 0) {
      console.log("❌ No podcast script available")
      return
    }

    console.log(`🚀 STARTING PODCAST with ${podcastScript.length} sections`)
    console.log("📝 Sections:", podcastScript.map((s, i) => `${i+1}. ${s.title}`))
    
    setIsPlaying(true)
    isPlayingRef.current = true // ✅ Set ref immediately
    setCurrentSection(0)
    setCurrentTime(0)
    
    // ✅ Start first section immediately
    setTimeout(() => {
      playSection(0)
    }, 100)
  }

  const pausePodcast = () => {
    console.log("⏸️ PAUSING PODCAST")
    setIsPlaying(false)
    isPlayingRef.current = false // ✅ Set ref immediately
    
    if (speechSynthesis.current.speaking) {
      speechSynthesis.current.cancel()
    }
    clearInterval(progressInterval.current)
    if (sectionTimeoutRef.current) {
      clearTimeout(sectionTimeoutRef.current)
      sectionTimeoutRef.current = null
    }
  }

  const resetPodcast = () => {
    console.log("🔄 RESETTING PODCAST")
    pausePodcast()
    setCurrentTime(0)
    setCurrentSection(0)
  }

  const skipToNext = () => {
    if (currentSection + 1 < podcastScript.length) {
      console.log(`⏭️ SKIPPING to section ${currentSection + 2}`)
      
      // Cancel current
      if (speechSynthesis.current.speaking) {
        speechSynthesis.current.cancel()
      }
      clearInterval(progressInterval.current)
      if (sectionTimeoutRef.current) {
        clearTimeout(sectionTimeoutRef.current)
      }
      
      // Start next
      setTimeout(() => {
        if (isPlayingRef.current) {
          playSection(currentSection + 1)
        }
      }, 200)
    }
  }

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  const progressPercentage = totalDuration > 0 ? (currentTime / totalDuration) * 100 : 0

  return (
    <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
      <div className="flex items-center space-x-2 mb-6">
        <Volume2 className="text-red-600" size={20} />
        <h3 className="text-xl font-semibold text-white">Audio Summary</h3>
        <span className="text-sm text-gray-400 bg-gray-700 px-2 py-1 rounded">
          {podcastScript.length} sections
        </span>
      </div>

      {/* Debug Info */}
      <div className="mb-4 p-2 bg-gray-700 rounded text-xs text-gray-300">
        Current: {currentSection + 1}/{podcastScript.length} • 
        Playing: {isPlaying ? 'YES' : 'NO'} • 
        Section: {podcastScript[currentSection]?.title || 'None'}
      </div>

      {/* Audio Player */}
      <div className="bg-gray-900 rounded-lg p-6 mb-6 border border-gray-600">
        {/* Progress Bar */}
        <div className="mb-6">
          <div className="flex justify-between text-sm text-gray-400 mb-2">
            <span>{formatTime(currentTime)}</span>
            <span>{formatTime(totalDuration)}</span>
          </div>
          <div className="w-full bg-gray-700 rounded-full h-3">
            <div 
              className="bg-gradient-to-r from-red-600 to-red-500 h-3 rounded-full transition-all duration-300"
              style={{ width: `${progressPercentage}%` }}
            />
          </div>
        </div>

        {/* Controls */}
        <div className="flex items-center justify-center space-x-4">
          <button
            onClick={resetPodcast}
            className="p-3 rounded-full bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors"
            title="Reset"
          >
            <RotateCcw size={18} />
          </button>
          
          <button
            onClick={skipToNext}
            disabled={currentSection + 1 >= podcastScript.length || !isPlaying}
            className="p-3 rounded-full bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-600 transition-colors"
            title="Next Section"
          >
            <SkipForward size={18} />
          </button>
          
          <button
            onClick={isPlaying ? pausePodcast : playPodcast}
            disabled={podcastScript.length === 0}
            className="p-5 rounded-full bg-red-600 text-white hover:bg-red-700 disabled:bg-gray-600 transition-all transform hover:scale-105"
            title={isPlaying ? "Pause" : "Play All Sections"}
          >
            {isPlaying ? <Pause size={28} /> : <Play size={28} />}
          </button>

          <div className="flex items-center space-x-2 text-gray-400">
            <Clock size={16} />
            <span className="text-sm">
              {Math.ceil(totalDuration / 60)} min
            </span>
          </div>
        </div>

        {/* Current Section Display */}
        {podcastScript[currentSection] && (
          <div className="mt-6 text-center">
            <div className={`inline-flex items-center space-x-3 rounded-full px-6 py-3 border ${
              isPlaying 
                ? 'bg-red-600/20 border-red-600/30' 
                : 'bg-gray-700/50 border-gray-600/30'
            }`}>
              <div className={`w-3 h-3 rounded-full ${
                isPlaying ? 'bg-red-400 animate-pulse' : 'bg-gray-400'
              }`} />
              <span className="text-sm font-medium text-white">
                {podcastScript[currentSection].title}
              </span>
              <span className="text-xs text-gray-400">
                ({currentSection + 1}/{podcastScript.length})
              </span>
            </div>
          </div>
        )}
      </div>

      {/* All Sections List */}
      <div className="space-y-2 max-h-48 overflow-y-auto">
        <h4 className="text-white font-medium mb-3">All Sections:</h4>
        {podcastScript.map((section, index) => (
          <div 
            key={index} 
            className={`p-3 rounded border transition-all ${
              currentSection === index 
                ? 'bg-red-900/30 border-red-600/50' 
                : currentSection > index
                  ? 'bg-green-900/20 border-green-600/30'
                  : 'bg-gray-900 border-gray-700'
            }`}
          >
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3">
                <span className="text-sm font-mono">
                  {currentSection === index && isPlaying ? '▶️' : 
                   currentSection > index ? '✅' : 
                   `${index + 1}.`}
                </span>
                <span className="text-sm text-white">{section.title}</span>
              </div>
              <span className="text-xs text-gray-500">{section.duration}s</span>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

export default PodcastMode
